#!/usr/bin/env python3
import argparse
import sys
import csv
import os
import copy
import dataclasses
import pprint
from datetime import datetime
from io import FileIO


# Tweakable parameters
PRINT_OPEN_CLOSE_MAP = False
SCRIPT_PREFIX = "scripts"
CSV_FILE_NAME = "open_close_times.csv"
C_SOURCE_OUTPUT = "open_close_times.cpp"
C_HEADER_OUTPUT = "open_close_times.h"
PYTHON_OUTPUT = "open_close_times.py"
MONTH_COMMENT = "Open-Close times specified as a 2D array for each month"
MONTH_PREFIX = "OC_TIME_"

# Constants
MONTHS = [
    "JANUARY",
    "FEBRUARY",
    "MARCH",
    "APRIL",
    "MAY",
    "JUNE",
    "JULY",
    "AUGUST",
    "SEPTEMBER",
    "OCTOBER",
    "NOVEMBER",
    "DECEMBER",
]


@dataclasses.dataclass
class DayInfo:
    open_hour = 0
    open_minute = 0
    close_hour = 0
    close_minute = 0


class MapEntry:
    valid = False
    day = 0
    month = 0
    day_info = DayInfo()


def main():
    parser = argparse.ArgumentParser(
        "Converter script to generate look-up table code for sun times"
    )
    parser.add_argument(
        "-t", "--type", help="Output code language", choices=["c", "py"], default="c"
    )
    args = parser.parse_args()
    print("-- Sun times to code generator --")
    ocm = gen_open_close_map()
    if args.type == "c":
        gen_c_file(ocm)
    elif args.type == "py":
        gen_py_file(ocm)
    else:
        print("No supported output code type detected")
        sys.exit(0)
    print("Done")


def gen_c_file(ocm):
    print(f"Generating {C_SOURCE_OUTPUT}")
    with open(C_SOURCE_OUTPUT, "w") as f:
        print_header_c(f)
        f.write("\n")
        f.write(f"// {MONTH_COMMENT}\n")
        for idx in range(0, 12):
            write_month_definition_c(f, idx, ocm)
            f.write("\n")
    print(f"Generating {C_HEADER_OUTPUT}")
    with open(C_HEADER_OUTPUT, "w") as f:
        print_header_c(f)
        f.write("\n")
        for idx in range(0, 11):
            write_month_declaration_c(f, idx)
        f.write("\n")


def gen_py_file(ocm):
    print(f"Generating {PYTHON_OUTPUT}")
    with open(PYTHON_OUTPUT, "w") as f:
        print_header_py(f)
        f.write("\n")
        f.write(f"# {MONTH_COMMENT}\n")
        for idx in range(0, 12):
            write_month_declaration_py(f, idx, ocm)
            f.write("\n")


def print_header_c(f: FileIO):
    f.write("/*\n * This file was auto-generated by the sun-times-to-code.py script.\n")
    f.write(f" * Generated on the {datetime.now()}.\n")
    f.write(" */\n")


def print_header_py(f: FileIO):
    f.write('"""\n')
    f.write("This file was auto-generated by the sun-times-to-code.py script.\n")
    f.write(f"Generated on the {datetime.now()}.\n")
    f.write('"""\n')


def write_month_definition_c(f: FileIO, month_idx: int, ocm: dict):
    f.write(f"const int {MONTH_PREFIX}{MONTHS[month_idx]}[31][4] = {{\n")
    for day_idx in range(0, 31):
        sep = ","
        if day_idx == 30:
            sep = ""
        month_dict = ocm[MONTHS[month_idx]]
        if month_dict.get(str(day_idx + 1)) != None:
            last_day_info = month_dict[str(day_idx + 1)]
        day_info = last_day_info
        f.write(
            f"    {{"
            f"{day_info.open_hour}, "
            f"{day_info.open_minute}, "
            f"{day_info.close_hour}, "
            f"{day_info.close_minute}"
            f"}}{sep}\n"
        )
    f.write("};\n")


def write_month_declaration_c(f: FileIO, month_idx: int):
    f.write(f"extern const int {MONTH_PREFIX}{MONTHS[month_idx]}[31][4];\n")


def write_month_declaration_py(f: FileIO, month_idx: int, ocm: dict):
    f.write(f"{MONTH_PREFIX}{MONTHS[month_idx]} = [\n")
    for day_idx in range(0, 31):
        sep = ","
        if day_idx == 30:
            sep = ""
        month_dict = ocm[MONTHS[month_idx]]
        if month_dict.get(str(day_idx + 1)) != None:
            last_day_info = month_dict[str(day_idx + 1)]
        day_info = last_day_info
        f.write(
            f"    ["
            f"{day_info.open_hour}, "
            f"{day_info.open_minute}, "
            f"{day_info.close_hour}, "
            f"{day_info.close_minute}"
            f"]{sep}\n"
        )
    f.write("]\n")


def gen_open_close_map() -> dict:
    csv_name = CSV_FILE_NAME
    if not os.path.exists(CSV_FILE_NAME):
        if os.path.exists(f"{SCRIPT_PREFIX}/{CSV_FILE_NAME}"):
            csv_name = f"{SCRIPT_PREFIX}/{CSV_FILE_NAME}"
        else:
            print(f"No CSV file {CSV_FILE_NAME} found")
            sys.exit(1)
    print(f"Generating map with open and close times from {csv_name}")
    with open(csv_name, "r") as csvfile:
        open_close = csv.reader(csvfile, delimiter=";")
        open_close_map = dict()
        for month in MONTHS:
            open_close_map[month] = dict()
        entry = MapEntry()
        for row in open_close:
            entry.valid_entry = False
            if len(row) == 3 and (entry != "" for entry in row):
                date_list = row[0].split(".")
                if (
                    len(date_list) > 2
                    and date_list[0] != ""
                    and date_list[1] != ""
                    and date_list[0].isdigit()
                ):
                    entry.day = int(date_list[0])
                    entry.month = int(date_list[1])
                else:
                    continue
                hour_minute_open = row[1].split(":")
                if len(hour_minute_open) == 2:
                    entry.day_info.open_hour = int(hour_minute_open[0])
                    entry.day_info.open_minute = int(hour_minute_open[1])
                else:
                    continue
                hour_minute_close = row[2].split(":")
                if len(hour_minute_close) == 2:
                    entry.day_info.close_hour = int(hour_minute_close[0])
                    entry.day_info.close_minute = int(hour_minute_close[1])
                    valid_entry = True
            if valid_entry:
                month_to_idx = int(entry.month) - 1
                open_close_map[MONTHS[month_to_idx]][str(int(entry.day))] = copy.copy(
                    entry.day_info
                )
        if PRINT_OPEN_CLOSE_MAP:
            pp = pprint.PrettyPrinter()
            pp.pprint(open_close_map)
    return open_close_map


if __name__ == "__main__":
    main()

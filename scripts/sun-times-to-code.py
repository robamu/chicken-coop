#!/usr/bin/env python3
import argparse
import sys
import csv
import os
import copy
import dataclasses
import pprint
import shutil
from datetime import datetime
from io import FileIO


# Tweakable parameters
PRINT_OPEN_CLOSE_MAP = False
INPUT = "in"
OUTPUT = "out"
SCRIPT_PREFIX = "scripts"
CSV_FILE_NAME = "open_close_times.csv"
C_SOURCE_OUTPUT = "open_close_times.cpp"
C_HEADER_OUTPUT = "open_close_times.h"
PYTHON_OUTPUT = "open_close_times.py"
C_DEST_ESP = "../chicken-coop-esp/main"
C_DEST_ARDUINO = "../chicken-coop-arduino/src"
PY_DEST_RPI = "../chicken-coop-pi"
MONTH_COMMENT = "Open-Close times specified as a 2D array for each month"
MONTH_PREFIX = "OC_TIMES_"

# Constants
MONTHS = [
    "JANUARY",
    "FEBRUARY",
    "MARCH",
    "APRIL",
    "MAY",
    "JUNE",
    "JULY",
    "AUGUST",
    "SEPTEMBER",
    "OCTOBER",
    "NOVEMBER",
    "DECEMBER",
]
C_SOURCE_FULL_PATH = os.path.join(OUTPUT, C_SOURCE_OUTPUT)
C_HEADER_FULL_PATH = os.path.join(OUTPUT, C_HEADER_OUTPUT)
PYTHON_FULL_OUTPUT = os.path.join(OUTPUT, PYTHON_OUTPUT)


@dataclasses.dataclass
class DayInfo:
    open_hour = 0
    open_minute = 0
    close_hour = 0
    close_minute = 0


class MapEntry:
    valid = False
    day = 0
    month = 0
    day_info = DayInfo()


def main():
    parser = argparse.ArgumentParser(
        "Converter script to generate look-up table code for sun times"
    )
    parser.add_argument(
        "-t", "--type", help="Output code language", choices=["c", "py"], default="c"
    )
    parser.add_argument(
        "-c",
        "--copy",
        help="Copy files to destination directory",
        action="store_true",
        default=False,
    )
    args = parser.parse_args()
    print("-- Sun times to code generator --")
    ocm = gen_open_close_map()
    if args.type == "c":
        gen_c_file(ocm)
    elif args.type == "py":
        gen_py_file(ocm)
    else:
        print("No supported output code type detected")
        sys.exit(0)
    if args.copy:
        if args.type == "c":
            cp_file_to_dest(C_SOURCE_FULL_PATH, C_DEST_ARDUINO)
            cp_file_to_dest(C_HEADER_FULL_PATH, C_DEST_ARDUINO)
            cp_file_to_dest(C_SOURCE_FULL_PATH, C_DEST_ESP)
            cp_file_to_dest(C_HEADER_FULL_PATH, C_DEST_ESP)
        elif args.type == "py":
            cp_file_to_dest(PYTHON_FULL_OUTPUT, PY_DEST_RPI)
    print("Done")


def cp_file_to_dest(source: str, dest: str):
    print(f"Copy {source} to {dest}")
    try:
        if os.path.exists(source):
            if os.path.exists(dest):
                shutil.copy(source, dest)
            else:
                print(f"Copy operation: Destination {dest} not found")
        else:
            print(f"Copy Operation: Source file {source} does not exists")
    except IsADirectoryError as e:
        print(f"Copy Operation: Failed with error: {e}")


def gen_py_file(ocm):
    print(f"Generating {PYTHON_OUTPUT}")
    with open(f"{OUTPUT}{os.pathsep}{PYTHON_OUTPUT}", "w") as f:
        print_header_py(f)
        f.write("\n")
        f.write(f"# {MONTH_COMMENT}\n")
        for idx in range(0, 12):
            write_month_declaration_py(f, idx, ocm)
            f.write("\n")


def gen_c_file(ocm):
    print(f"Generating {OUTPUT}/{C_SOURCE_OUTPUT}")
    with open(f"{os.path.join(OUTPUT, C_SOURCE_OUTPUT)}", "w") as f:
        print_header_c(f)
        f.write("\n")
        f.write('#include "open_close_times.h"\n')
        f.write("\n")
        print_open_close_months_definition(f)
        f.write(f"// {MONTH_COMMENT}\n")
        for idx in range(0, 12):
            write_month_definition_c(f, idx, ocm)
            if idx < 11:
                f.write("\n")
    print(f"Generating {OUTPUT}/{C_HEADER_OUTPUT}")
    with open(f"{os.path.join(OUTPUT, C_HEADER_OUTPUT)}", "w") as f:
        print_header_c(f)
        f.write("\n")
        f.write("// Wrapper to allow clean typedef\n")
        f.write("typedef struct OcTableWrapper {\n")
        f.write("    int month[31][4];\n")
        f.write("};\n")
        f.write("\n")
        f.write("// Structure to access months via array index 0 to 11\n")
        f.write("extern const OcTableWrapper* OPEN_CLOSE_MONTHS[12];\n")
        f.write("\n")
        for idx in range(0, 12):
            write_month_declaration_c(f, idx)
            if idx < 11:
                f.write("\n")


def print_open_close_months_definition(f: FileIO):
    f.write("const OcTableWrapper* OPEN_CLOSE_MONTHS[12] = {\n")
    for month_idx in range(0, 12):
        f.write(f"    &{MONTH_PREFIX}{MONTHS[month_idx]},\n")
    f.write("};\n")
    f.write("\n")


def print_header_c(f: FileIO):
    f.write("/*\n * This file was auto-generated by the sun-times-to-code.py script.\n")
    f.write(f" * Generated on the {datetime.now()}.\n")
    f.write(" */\n")


def print_header_py(f: FileIO):
    f.write('"""\n')
    f.write("This file was auto-generated by the sun-times-to-code.py script.\n")
    f.write(f"Generated on the {datetime.now()}.\n")
    f.write('"""\n')


def write_month_definition_c(f: FileIO, month_idx: int, ocm: dict):
    f.write(f"const OcTableWrapper {MONTH_PREFIX}{MONTHS[month_idx]} = {{\n")
    f.write("    .month = {\n")
    for day_idx in range(0, 31):
        sep = ","
        if day_idx == 30:
            sep = ""
        month_dict = ocm[MONTHS[month_idx]]
        if month_dict.get(str(day_idx + 1)) != None:
            last_day_info = month_dict[str(day_idx + 1)]
        day_info = last_day_info

        f.write(
            f"        {{"
            f"{day_info.open_hour}, "
            f"{day_info.open_minute}, "
            f"{day_info.close_hour}, "
            f"{day_info.close_minute}"
            f"}}{sep}\n"
        )
    f.write("    }\n")
    f.write("};\n")


def write_month_declaration_c(f: FileIO, month_idx: int):
    f.write(f"extern const OcTableWrapper {MONTH_PREFIX}{MONTHS[month_idx]};")


def write_month_declaration_py(f: FileIO, month_idx: int, ocm: dict):
    f.write(f"{MONTH_PREFIX}{MONTHS[month_idx]} = [\n")
    for day_idx in range(0, 31):
        sep = ","
        if day_idx == 30:
            sep = ""
        month_dict = ocm[MONTHS[month_idx]]
        if month_dict.get(str(day_idx + 1)) != None:
            last_day_info = month_dict[str(day_idx + 1)]
        day_info = last_day_info
        f.write(
            f"    ["
            f"{day_info.open_hour}, "
            f"{day_info.open_minute}, "
            f"{day_info.close_hour}, "
            f"{day_info.close_minute}"
            f"]{sep}\n"
        )
    f.write("]\n")


def gen_open_close_map() -> dict:
    csv_name = os.path.join(INPUT, CSV_FILE_NAME)
    if not os.path.exists(csv_name):
        alt_name = os.path.join(SCRIPT_PREFIX, csv_name)
        if os.path.exists(alt_name):
            csv_name = alt_name
        else:
            print(f"No CSV file {csv_name} or {alt_name} found")
            sys.exit(1)
    print(f"Generating map with open and close times from {csv_name}")
    with open(csv_name, "r") as csvfile:
        open_close = csv.reader(csvfile, delimiter=";")
        open_close_map = dict()
        for month in MONTHS:
            open_close_map[month] = dict()
        entry = MapEntry()
        for row in open_close:
            entry.valid_entry = False
            if len(row) == 3 and (entry != "" for entry in row):
                date_list = row[0].split(".")
                if (
                    len(date_list) > 2
                    and date_list[0] != ""
                    and date_list[1] != ""
                    and date_list[0].isdigit()
                ):
                    entry.day = int(date_list[0])
                    entry.month = int(date_list[1])
                else:
                    continue
                hour_minute_open = row[1].split(":")
                if len(hour_minute_open) == 2:
                    entry.day_info.open_hour = int(hour_minute_open[0])
                    entry.day_info.open_minute = int(hour_minute_open[1])
                else:
                    continue
                hour_minute_close = row[2].split(":")
                if len(hour_minute_close) == 2:
                    entry.day_info.close_hour = int(hour_minute_close[0])
                    entry.day_info.close_minute = int(hour_minute_close[1])
                    valid_entry = True
            if valid_entry:
                month_to_idx = int(entry.month) - 1
                open_close_map[MONTHS[month_to_idx]][str(int(entry.day))] = copy.copy(
                    entry.day_info
                )
        if PRINT_OPEN_CLOSE_MAP:
            pp = pprint.PrettyPrinter()
            pp.pprint(open_close_map)
    return open_close_map


if __name__ == "__main__":
    main()
